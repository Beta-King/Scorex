package scorex.block

import io.circe.Json
import scorex.consensus.ConsensusModule
import scorex.serialization.{BytesSerializable, JsonSerializable}
import scorex.transaction.box.proposition.Proposition
import scorex.transaction.{Transaction, TransactionModule}
import scorex.utils.ScorexLogging
import scala.util.Try

/**
  * A block is an atomic piece of data network participates are agreed on.
  *
  * A block has:
  * - transactions data: a sequence of transactions, where a transaction is an atomic state update.
  * Some metadata is possible as well(transactions Merkle tree root, state Merkle tree root etc).
  *
  * - consensus data to check whether block was generated by a right party in a right way. E.g.
  * "baseTarget" & "generatorSignature" fields in the Nxt block structure, nonce & difficulty in the
  * Bitcoin block structure.
  *
  * - a signature(s) of a block generator(s)
  *
  * - additional data: block structure version no, timestamp etc
  */

class Block[P <: Proposition, CData <: ConsensusData, TData <: TransactionalData[_ <: Transaction[P, _]]](
                                                                                      val version: Byte,
                                                                                      val timestamp: Long,
                                                                                      val consensusData: CData,
                                                                                      val transactionalData: TData)
  extends BytesSerializable with JsonSerializable {

  type TDataExposed = TData
  type BlockId = ConsensusData.BlockId

  lazy val bytes: Array[Byte] = ???

  lazy val json: Json = ???

  /*lazy val json =
    versionField.json ++
      timestampField.json ++
      consensusDataField.json ++
      transactionDataField.json ++
      Json.obj(
        "fee" -> consensusModule.totalFee(this),
        "blocksize" -> bytes.length
      )*/

  /*
  override def equals(obj: Any): Boolean = obj match {
    case b: Block => consensusModule.id(b).unsized sameElements consensusModule.id(this).unsized
    case _ => false
  } */
}

object Block extends ScorexLogging {
  val Version = 1: Byte

  def parse[P <: Proposition, TX <: Transaction[P, TX], CData <: ConsensusData, TData <: TransactionalData[TX]]
  (bytes: Array[Byte])
  (implicit consensusModule: ConsensusModule[P, TX, TData, CData],
   transactionalModule: TransactionModule[P, TX, TData]): Try[Block[P, CData, TData]] = {

    ???
  }

  def build[P <: Proposition, TX <: Transaction[P, TX], CData <: ConsensusData, TData <: TransactionalData[TX]]
  (consensusData: CData)
  (transactionalData: TData): Block[P, CData, TData] = {

    val timestamp = System.currentTimeMillis()
    new Block(Version, timestamp, consensusData, transactionalData)
  }

  def genesis[P <: Proposition, TX <: Transaction[P, TX], CData <: ConsensusData, TData <: TransactionalData[TX]]
  (genesisTimestamp: Long)
  (implicit consensusModule: ConsensusModule[P, TX, TData, CData],
   transactionalModule: TransactionModule[P, TX, TData]): Block[P, CData, TData] = {

    new Block(Version, genesisTimestamp, consensusModule.genesisData, transactionalModule.genesisData)
  }

  def isValid[P <: Proposition, TX <: Transaction[P, TX], CData <: ConsensusData, TData <: TransactionalData[TX]]
  (block: Block[P, CData, TData])
  (implicit consensusModule: ConsensusModule[P, TX, TData, CData],
   transactionalModule: TransactionModule[P, TX, TData]): Boolean = {

    if (consensusModule.contains(block)) true //applied blocks are valid
    else {
      lazy val consensus = consensusModule.isValid(block)
      lazy val transaction = transactionalModule.isValid(block.transactionalData)

      if (!consensus) log.debug(s"Invalid consensus data in block ${consensusModule.encodedId(block)}")
      else if (!transaction) log.debug(s"Invalid transaction data in block ${consensusModule.encodedId(block)}")

      consensus && transaction
    }
  }
}